#pragma config(Sensor, port2,  gyro,           sensorVexIQ_Gyro)
#pragma config(Sensor, port3,  light,          sensorVexIQ_ColorGrayscale)
#pragma config(Motor,  motor1,          leftMotor,     tmotorVexIQ, openLoop, driveLeft, encoder)
#pragma config(Motor,  motor6,          rightMotor,    tmotorVexIQ, openLoop, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*						Path finding code
**            Uses wave pathfinding to solve a 3x7 maze set in the beggining of the program
**            Written by Gaurav Rao under guidance of KK Quah
**            6/26/2017
*/



#define EAST 0; //for some reason these define statements aren't working so the numbers are used throughout the code. The robot should start "east"
#define NORTH 1;// Even though these definitions aren't used programatically, just use them as a reference
#define WEST 2;
#define SOUTH 3;

float wheelDiameter = 2.5;
float tileDistance = 12;


int grid [3][7] = {0,1,0,0,0,1,1,
		                 0,1,0,1,0,0,1,  // grids with 1's are obstacles
	                   0,0,0,1,0,0,2}; //	grid[2][5] = 2 is target


int maxSpeed =50;

int slowSpeed = 15;

void setObstacles(){
	int x =0;
	int y =0;
	int ctr = 0;
	int yMoved = 0;
	int xMoved = 0;
	while(getJoystickValue(BtnRUp)==0){
		if(getJoystickValue(BtnFUp)||getJoystickValue(BtnFDown)){
			if(0==yMoved){
				if(getJoystickValue(BtnFUp))
					y--;
				else
					y++;
			}
			yMoved=1;

		}else{
			yMoved=0;
	  }
	  if(getJoystickValue(BtnEUp)||getJoystickValue(BtnEDown)){
			if(0==xMoved){
				if(getJoystickValue(BtnEUp))
					x--;
				else
					x++;
			}
			xMoved=1;

		}else{
			xMoved=0;
	  }
	  y = (y+3)%3;
	  x = (x+7)%7;

	  if(getJoystickValue(BtnLUp)){
	  	grid[y][x]=1;
	  }
	  if(getJoystickValue(BtnLDown)){
	  	grid[y][x]=0;
	  }
	  grid[0][0] = 0;
	  grid[2][6] = 2;
	  char displayGrid[3][7];
	  for(int i=0; i <3;i++){
	  	for(int j=0; j <7;j++){
	  		if(ctr>50 && j == x && i == y){
	  			displayGrid[i][j]='X';
	  		}else{
	  			if(i==j && j==0)
	  				displayGrid[i][j] = 'S';
	  			else if (grid[i][j] == 2)
	  				displayGrid[i][j] = 'E';
	  			else if(grid[i][j]==0)
	  				displayGrid[i][j]=' ';
	  			else
	  				displayGrid[i][j]='W';

	  		}
	  	}
	  }



		if(ctr++ >100){
			ctr = 0;
		}
			eraseDisplay();
	for (int r=0; r<3; r++) {
		displayTextLine(r, "%c %c %c %c %c %c %c",
		displayGrid[r][0],displayGrid[r][1],displayGrid[r][2],displayGrid[r][3],displayGrid[r][4],displayGrid[r][5],displayGrid[r][6]);

	}
	displayTextLine(3,"X=%d Y=%d S: Start ",x,y);
	displayTextLine(4,"E: End W: Wall");
		delay(10);
	}
}

void iqCalibrateGyro() //This is gyro callibraton code stolen from the internet
{

	int count = 20;
	startGyroCalibration( gyro, gyroCalibrateSamples512 );
	// delay so calibrate flag can be set internally to the gyro
	wait1Msec(100);

	// wait for calibration to finish or 2 seconds, whichever is longer
	while( getGyroCalibrationFlag(gyro) || (count-- > 0) ) {
		wait1Msec(100);
	}
	resetGyro(gyro);

}

int inRange (int i, int j){ //function to test whether a coordinate is within the bounds of the array
	return !(i<0 || i>=3||j<0||j>=7);
}

void turnTo(int heading){ //function that turns to the headings defined above
	while(heading*90 - getGyroDegrees(gyro)>180){

		heading -=4;
	}
	while(heading*90 - getGyroDegrees(gyro)<-180){
		heading +=4;
	}


	if(heading*90 > getGyroDegrees(gyro)){
		while(getGyroDegrees(gyro)+30  < heading*90){
			motor[leftMotor]=-maxSpeed;
			motor[rightMotor]=maxSpeed;
		}
		while(getGyroDegrees(gyro)  < heading*90){
			motor[leftMotor]=-slowSpeed;
			motor[rightMotor]=slowSpeed;
		}

		}else{
		while(getGyroDegrees(gyro)-30  > heading*90){
			motor[leftMotor]=maxSpeed;
			motor[rightMotor]=-maxSpeed;
		}
		while(getGyroDegrees(gyro)  > heading*90){
			motor[leftMotor]=slowSpeed;
			motor[rightMotor]=-slowSpeed;
		}
	}


	motor[leftMotor]=0;
	motor[rightMotor]=0;

}

void moveInches(float inches){ //function that moves the robot forward a number of inches
	float cir = wheelDiameter*PI;
	int degrees = (int)((360.0*inches)/cir);

	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	while(getMotorEncoder(leftMotor)<degrees||getMotorEncoder(rightMotor)<degrees){

		if(getMotorEncoder(leftMotor)+180<degrees){
			motor[leftMotor]=maxSpeed;
			}else if(getMotorEncoder(leftMotor)<degrees){
			motor[leftMotor]=slowSpeed;
			}else{
			motor[leftMotor]=0;
		}

		if(getMotorEncoder(rightMotor)+180<degrees){
			motor[rightMotor]=maxSpeed;

		}else if(getMotorEncoder(rightMotor)<degrees){
			motor[rightMotor]=slowSpeed;

		}else{
			motor[rightMotor]=0;
		}
	}
	motor[leftMotor]=0;
	motor[rightMotor]=0;
}



task main()
{

	resetGyro(gyro);
	setObstacles();


	// Display Grid
	eraseDisplay();
	for (int r=0; r<3; r++) {
		displayTextLine(r, "%d %d %d %d %d %d %d",
		grid[r][0],grid[r][1],grid[r][2],grid[r][3],grid[r][4],grid[r][5],grid[r][6]);

	}

	iqCalibrateGyro();//callibrate the gyro, also functions as a pause so we can see the grid

	eraseDisplay();
	//find the wave numbers

	for(int step=2;step<25;step++){	//step referes to how many steps away from the end the alg is checking

		for(int i =0;i<3;i++){ //i is the y coordinate that the alg is checking
			for(int j =0; j<7; j++){ //j is the x coordinate that the alg is checking.

				if(grid[i][j] == step){
					int itemp = i-1; //I have no idea why using this variable is necessary but the program doesn't compile without it
                           //It seems to be a bug within robotC, something about being nested too much
					int jtemp = j-1;
					if(inRange(i+1,j) && grid[i+1][j] == 0) grid[i+1][j]= step+1; //check the coordinate directly south
					if(inRange(itemp,j) &&grid[itemp][j] == 0) grid[itemp][j] = step +1; //check the coordinate directly north (replacing itemp with i-1 breaks it for some reaon)
					if(inRange(i,j+1) && grid[i][j+1] == 0) grid[i][j+1]= step+1; //check the coordinate directly east
					if(inRange(i,jtemp) && grid[i][jtemp] == 0) grid[i][jtemp]= step+1; //check the coordinate directly west
				}
			}

		}
	}

	//display wave numbers
	for (int r=0; r<3; r++) {
		displayTextLine(r, "%2d %2d %2d %2d %2d %2d %2d",
		grid[r][0],grid[r][1],grid[r][2],grid[r][3],grid[r][4],grid[r][5],grid[r][6]);

	}

	delay(2000);//Pause so we can look at the wave numbers again

	int dist = grid[0][0];
	int steps[25];
	int x = 0;
	int y =0;

	if(dist==0){
		displayTextLine(3,"NO PATH FOUND");
		delay(10000);
		return;
	}
	//use the wave numbers to generate a path
	for(int i= dist; i>2; i--){
		int temp = y-1; //same as above, I don't know why this is necessary
		int xtemp = x-1;
		if( inRange(y+1,x) && grid[y+1][x] == i-1){
			steps[dist-i] = 3;
			y++;
			continue;
		}

		if( inRange(y,x+1) && grid[y][x+1] == i-1){
			steps[dist-i] = 0;
			x++;
			continue;
		}

		if( inRange(y,xtemp) && grid[y][xtemp] == i-1){
			steps[dist-i] = 2;
			x--;
			continue;
		}
		if( inRange(temp,x) && grid[temp][x] == i-1){
			steps[dist-i] = 1;
			y--;
			continue;
		}
	}
	//display path on screen
	string out = "";
	for(int i=0;i<dist-2; i++){//this for loop just creates a string of directions for the path of the robot
		switch(steps[i]){
		case 2 :
			strcat(out,"W");
			break;
		case 1 :
			strcat(out,"N");
			break;
		case 3 :
			strcat(out, "S");
			break;

		case 0 :
			strcat(out, "E");
			break;
		default :
			break;

		}
	}
	displayText(3,out);
	delay(2000); //wait so we can see the path
	//execute path
	for(int i=0;i<dist-2; i++){
		displayTextLine(4,"Step number: %d",i+1);

		turnTo(steps[i]);
		delay(1000);

		moveInches(tileDistance);
		delay(1000);
	}
}
